### 马拉车算法的原理以及实现

实在受不了印象笔记那傻逼的编辑功能了，剪藏点带格式的网页基本上不能编辑。

看了wiki,简书，官方题解...等几百个版本之后，我终于搞定了这一篇。

wiki对基本情况的划分很好。

简书的解释不足，是本篇的前传。

官方题解很好，是另一种实现。

来自[这里](https://www.jianshu.com/p/392172762e55)。

### 正文：

###### 1.预处理：

回文串有奇偶两种情况，即中心是空还是一个字符。
为了统一处理，在每个字符的左右两边都加上一个不存在于原始字符串中的字符来使其成为一个奇数长度的回文。

```bash
abba    =>  #a#b#b#a#   4=>9
aba     =>  #a#b#a#     3=>7
```

可见无论原始字符串是奇数还是偶数，处理之后都是奇数长度。

#### 2.计算最长回子串的长度

对于字符 ``cabbaf``,预处理之后为 ``#c#a#b#b#a#f#``,定义一个等长数组来表示该字符串以i为中心时候的最长回文串半径。
因为字符本身也属于回文，所以默认值初始化为1

```bash
i      0 1 2 3 4 5 6 7 8 9 10 11 12
arr[i] # c # a # b # b # a #  f  #
p[i]   1 2 1 2 1 2 5 2 1 2 1  2  1
```

上图为计算好了最大长度数组p的一个例子，通过观察来得出最长回文串半径与原字符串之间的关系。
上文最长回文子串是以p[6]为中心的，半径为5，代表的原始字符串为 ``abba``,其长度为4，恰好是比半径小1，为什么会这样呢？
因为每个原始字符两边都添加了 ``#``,所以数量上恰好有此关系。
其他例子
`` "aba"``，转换后是 ``"#a#b#a#"``，以字符 ``'b'``为中心的回文，半径是4，减1得到3，3是原字符串的最长回文子串长度。
``"effe"``，转换后是 ``"#e#f#f#e#"``，以最中间的 ``'#'``为中心的回文，半径是5，减1得到4，4是原字符串的最长回文子串长度。

观察得出最长回文半径和初始的最长回文子串 ``maxLength``关系为:

```cpp
int maxLength=p[i]-1
```

#### 3.计算起始索引

有了中心点和长度，需要计算一下起始索引位置，才能截取子串。
这里存在另一个关系，对于半径数组p[i],其索引值减去数组元素值恰好是该子串(在最初字符串s里)的起始索引
比如上面例子 ``"cabbaf"``,``p[6]==5``为最长半径，i(6)-p[i](5)==1恰好为 ``abba``的起始索引。
但是对于初始字符串的子串是奇数的情况，比如 ``"aba"``,加入padding之后是 ``"#a#b#a#"``,其本身的长度是奇数没错，但是i(3)-p[i](4)不再遵从上一段发现的规律，结果为负值。
也就是说，**在字符串为奇数的情况下，当整个串都是回文的时候 该计算会溢出。**

为了应对这种情况，我们在转换后的字符串前面再加一个特殊字符，在这里是 ``^``,因为继续添加 ``#``会干扰计算。
而前面 ``预处理``部分提到，padding之后字符串长度是奇数，这里变成偶数之后就不再满足 ``计算最长回子串的长度``部分提到的条件了，所以在末尾再加一个不存在于字符串里的特殊字符 ``@``.
(注:这里添加@是为了保证在全串为回文的情况下，中心点左右两边的长度相等，若无此@符号，计算时候右边会越界。且实际上下面的循环里，这个符号不会被访问，到n-1就完了）

[这里](https://youtu.be/5Rqomc7na7A?t=1227 "youtube题解")就完全没提开头和末尾的特殊字符。

解决了奇数的问题，要观察此添加是否会影响偶数的情况，考虑例子

```bash
i      0 1 2 3 4 5 6 7 8 9 10 11 12 13
arr[i] $ # c # a # b # b # a  #  f  #
p[i]     1 2 1 2 1 2 5 2 1 2  1  2  1
```

在补上字符 ``'$'``后，``p[7]``=5，用i减去最长半径，7-5=2，而理想的结果应该是1，这里再莫名其妙的 除以2，得到我们想要的1。
而奇回文"aba"在用i减去最长半径后得到的是0，除以2后还是0，所以除以2不影响奇回文的情况。

于是得到规律，在经过上述一堆补丁之后，有如下关系：
最长回文子串的起始索引 ``int index = (i - p[i])/2``

#### 4.计算p数组

对于例子

```bash
i       0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
arr[i]  $ # c # a # b # b # a  #  f  #  @
p[i]      1 2 1 2 1 2 5 2 1 2  1  2  1
```

创建变量 ``id``和 ``mx``。        //待会再加。
``id``是**所有回文子串中**，能延伸到最右端位置的那个回文子串的中心点位置。
``mx``是该回文串能延伸到的最右端的位置。

当i等于7时，id等于7，p[id] = 5，在以位置7为中心的回文子串中，该回文子串的右边界是位置12。
当i等于12时，id等于12，p[id] = 2，在以位置12为中心的回文子串中，该回文子串的右边界是位置14。
由此我们可以得出回文子串右边界和其半径之间的关系：mx = p[id]+id。

在以id为中心,mx为右边界的情况下任意取一个位置 i ,满足i∈(id,mx),考虑i的右边界与mx的关系,有两种可能.

###### 1.`i`的右边界小于等于 `mx`

因为回文字符串是中心对称的，在中心点位置为id的情况下，如果一个回文子串以 `i`为中心，并且被包含在以 `id`为中心的回文子串中，亦即它的右边界没有超过 `id`的边界，那么肯定会存在另外一个以 `j`为中心的回文子串，和以 `i`为中心的回文子串相等且对称，即 `p[j] = p[i]`.
而 `i`和 `j`是以 `id`为中心对称，即 ``i+j=2*id``，如果知道了 `i`的值，那么 ``j = 2*id - i`` 这样就可以利用计算过的 `p[j]`的值来快速跳过一些关于i的计算.

###### 2.`i`的右边界大于 `mx`(或者描述为"至少为 `mx`")

如果以 i 为中心的回文子串右边界超过了mx，在i到mx的这段回文子串中，与另一端对称的以j为中心的回文子串还是相等的(这一点由"`id`为中心的是一个回文串"来保证).
此时 `p[i] = mx - i，p[j] = p[i]`.
至于右边界mx之外的子串，即以i为中心的回文子串超出的部分是否还是满足上述条件就需要遍历比较字符了。 *这里对应的是wiki的情况3*

综合上述两种情况，在 ``mx > i``的情况下，`p[i] = Math.min(p[2*id - i], mx - i)`。

这里还有一点没提的是，``id``和 ``mx``的更新，[这里](https://youtu.be/5Rqomc7na7A?t=1227 "youtube题解")有明确的解释。
不过它的代码跟这个不同，懒得看了。

代码如下:

```cpp

 string Manacher(string s) {
	if (s.length() < 2) {
		return s;
	}
	// 第一步：预处理，将原字符串转换为新字符串
	string t = "$";
	for (int i = 0; i < s.size(); i++) {
		t += "#" + s[i];
	}
	// 尾部加上字符@，变为奇数长度字符串
	t += "#@";

	// 第二步：计算数组p、起始索引、最长回文半径
	int n = t.size();
	vector<int> p(n,0);	// p数组
	int id = 0, mx = 0;
	int maxLength = -1;// 最长回文子串的长度
	int index = 0;	// 最长回文子串的中心位置索引

	for (int j = 1; j < n - 1; j++) {	//注意这里的for循环是到n-1为止的，所以实际上不会j处理到@,也就是说，不会拿他当中心点处理，但是mx会到达这里，因为其是根据index和len来计算的，左边界到达新家字符^的时候，右边就会到达此字符。
		p[j] = mx > j ? std::min(p[2 * id - j], mx - j) : 1;
		// 向左右两边延伸，扩展右边界
		//这里的j+p[j]就是右边界，未必超过了mx。
		while (t[j + p[j]] == t[j - p[j]]) {
			p[j]++;
		}
		// 如果回文子串的右边界超过了mx，则需要更新mx和id的值  这里，你一下子跳了那么多，两步之间的节点怎么办？
        //谁来给它们赋值？
        //id是不可能超过j的，j是逐个遍历的，完结。
		if (mx < p[j] + j) {
			mx = p[j] + j;
			id = j;
		}
		// 如果回文子串的长度大于maxLength，则更新全局的maxLength和index的值
		if (maxLength < p[j] - 1) {
			maxLength = p[j] - 1;
			index = j;
		}
	}
	// 第三步：截取字符串，输出结果
	// 起始索引的计算参看前文第四部分
	int start = (index - maxLength) / 2;
	return s.substring(start, start + maxLength);
}

```

为了使得扩展的过程中，到边界后自动结束，在两端分别插入 "^" 和 "$"，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。
https://www.zhihu.com/question/37289584/answer/465656849


动态过程
https://www.zhihu.com/question/37289584/answer/677058222

看了这个过程我觉得他说的是对的，我说的没错是为了不越界访问，但是理解错了，不是为了借左边部分来跳的时候跳到末尾，而是压根就不会访问末尾，且是为了退出扩展循环用的。


在s_ext两侧再各加一个字符，如'^'或'$'。假设字符串里不可能出现'^'或'$'，如此，扩展到边界的时候代码里的while循环自然检测到两侧字符不相同而终止。这样写减少了while循环的判断条件，但不严谨。
https://www.zhihu.com/question/37289584/answer/1111317244

我跟人说的时候他们以为我理解了这一点，实际上我现在才知道。

这是另一个实现
```cpp

// https://www.zhihu.com/question/37289584/answer/465656849
class Solutiaon {
public:
	// Transform S into T.
	// For example, S = "abba", T = "^#a#b#b#a#$".
	// ^ and $ signs are sentinels appended to each end to avoid bounds checking
	//插入某符号.
	string preProcess(const string& s) {
		int n = s.length();
		if (n == 0) return "^$";    //长度为0，只加首尾。
		string ret = "^";    //这里的开头加的是^
		for (int i = 0; i < n; i++) ret += "#" + s.substr(i, 1);
		ret += "#$";	//不分奇偶，末尾都加个$.
		return ret;
	}

	string longestPalindrome(string s) {
		string T = preProcess(s);    //把奇偶次数同化
		cout << T;
		const int n = T.length();    //处理后的长度
		//以T[i]为中心，向左/右扩张的长度，不包含T[i]自己,
		//因此P[i]是源字符串中回文串的长度

		vector<int> P(n,0);    //用来存每个字母为中心的回文长度.
		int C = 0, R = 0;
		for (int i = 1; i < n - 1; i++) {    //遍历每个字母
			int i_mirror = 2 * C - i; // equals to i' = C - (i-C)
			P[i] = (R > i) ? min(R - i, P[i_mirror]) : 0;
			// Attempt to expand palindrome centered at i
			while (T[i + 1 + P[i]] == T[i - 1 - P[i]])
				P[i]++;
			// If palindrome centered at i expand past R,
			// adjust center based on expanded palindrome.
			if (i + P[i] > R) {    //于是这个就是while之外的判断了？ 如果大于右边，则...跳过?
				C = i;
				R = i + P[i];
			}
		}
		// Find the maximum element in P.
		int max_len = 0;
		int center_index = 0;
		for (int i = 1; i < n - 1; i++) {
			if (P[i] > max_len) {
				max_len = P[i];
				center_index = i;
			}
		}
		return s.substr((center_index - 1 - max_len) / 2, max_len);
	}
};

```
